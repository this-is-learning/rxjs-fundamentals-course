"use strict";(self.webpackChunkrxjs_fundamentals_course=self.webpackChunkrxjs_fundamentals_course||[]).push([[109],{9222:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return p},default:function(){return c}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],i={id:"part-3",title:"Part 3. The most common RxJS operators"},l="The most common RxJS operators",m={unversionedId:"part-3",id:"part-3",isDocsHomePage:!1,title:"Part 3. The most common RxJS operators",description:"Contributors:",source:"@site/docs/part-3.md",sourceDirName:".",slug:"/part-3",permalink:"/rxjs-fundamentals-course/docs/part-3",editUrl:"https://github.com/this-is-learning/rxjs-fundamentals-course/edit/main/docs/part-3.md",tags:[],version:"current",frontMatter:{id:"part-3",title:"Part 3. The most common RxJS operators"},sidebar:"tutorialSidebar",previous:{title:"Part 2. Reactive programming and RxJS",permalink:"/rxjs-fundamentals-course/docs/part-2"},next:{title:"Part 4. How RxJS is used by Angular",permalink:"/rxjs-fundamentals-course/docs/part-4"}},p=[{value:"<strong>from()</strong>",id:"from",children:[]},{value:"<strong>map()</strong>",id:"map",children:[]},{value:"<strong>filter()</strong>",id:"filter",children:[]},{value:"<strong>skip(), first(), take()</strong>",id:"skip-first-take",children:[]},{value:"<strong>distinct()</strong>",id:"distinct",children:[]},{value:"<strong>distinctUntilChanged()</strong>",id:"distinctuntilchanged",children:[]},{value:"<strong>timer()</strong>",id:"timer",children:[]},{value:"<strong>interval</strong>",id:"interval",children:[]},{value:"<strong>combineLatest()</strong>",id:"combinelatest",children:[]},{value:"<strong>withLatestFrom()</strong>",id:"withlatestfrom",children:[]}],u={toc:p};function c(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-most-common-rxjs-operators"},"The most common RxJS operators"),(0,o.kt)("p",null,"Contributors:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Andrew Grekov"),(0,o.kt)("li",{parentName:"ul"},"Armen Vardanyan")),(0,o.kt)("h1",{id:"rxjs-operators-that-we-use-on-a-daily-basis"},(0,o.kt)("strong",{parentName:"h1"},"RxJS operators that we use on a daily basis")),(0,o.kt)("h1",{id:"comment"},"Comment"),(0,o.kt)("p",null,"When we first begin to work with ",(0,o.kt)("strong",{parentName:"p"},"RxJS"),", we need to learn about several operators that we will be using all the time. In this part of the course we will learn about the most common operators and also use them in practice."),(0,o.kt)("h1",{id:"changing-values-in-a-stream"},(0,o.kt)("strong",{parentName:"h1"},"Changing values in a stream")),(0,o.kt)("h2",{id:"from"},(0,o.kt)("strong",{parentName:"h2"},"from()")),(0,o.kt)("p",null,"To start working with ",(0,o.kt)("strong",{parentName:"p"},"RxJS")," streams, we will use ",(0,o.kt)("strong",{parentName:"p"},"from()")," to create some ",(0,o.kt)("inlineCode",{parentName:"p"},"Observables"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"from()")," creates a stream from items of an iterable value. For example, if we pass an ",(0,o.kt)("inlineCode",{parentName:"p"},"Array"),", it will create a stream with items from it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nconst source = from([1, 2, 3]);\n\n// Will log:\n\n//. 1\n\n//. 2\n\n//. 3\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"As seen in the example, ",(0,o.kt)("strong",{parentName:"p"},"from()")," creates a stream of values from its argument."),(0,o.kt)("h2",{id:"map"},(0,o.kt)("strong",{parentName:"h2"},"map()")),(0,o.kt)("p",null,"Creating a stream is cool and fun, but it would be even more awesome if we learn to change values in that stream. For example, let's multiply every number in a stream by 2. For that purpose we can use the ",(0,o.kt)("strong",{parentName:"p"},"map()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"map()")," works on every item in the stream one-by-one. It is fully analogous to ",(0,o.kt)("strong",{parentName:"p"},"Array.prototype.map"),", just for streams."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { map } from "rxjs/operators";\n\nconst source = from([1, 2, 3]).pipe(\n  // multiply every value by 2\n\n  map((value) => value * 2)\n);\n\n// Will log:\n\n//. 2\n\n//. 4\n\n//. 6\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"As seen from this example, ",(0,o.kt)("strong",{parentName:"p"},"map()")," allows us to receive every item, change it, and return it back to the stream."),(0,o.kt)("h1",{id:""}),(0,o.kt)("h1",{id:"filtering-items-in-a-stream"},(0,o.kt)("strong",{parentName:"h1"},"Filtering items in a stream")),(0,o.kt)("h2",{id:"filter"},(0,o.kt)("strong",{parentName:"h2"},"filter()")),(0,o.kt)("p",null,"Sometimes we are facing a task, when we do not want some items from the stream to pass forward. For example, we want only even numbers to pass. For that purpose, we use the ",(0,o.kt)("strong",{parentName:"p"},"filter()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"filter()")," operator filters items of the stream based on a condition provided by a callback function, which receives every item, and returns a boolean indicating whether that value should or should not pass (such functions are usually called predicates). This is fully analogous to ",(0,o.kt)("strong",{parentName:"p"},"Array.prototype.filter"),", but for streams."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { filter } from "rxjs/operators";\n\nconst source = from([1, 2, 3, 4]).pipe(\n  // Check if the value is even\n\n  filter((value) => value % 2 === 0)\n);\n\n// Will log:\n\n//. 2\n\n//. 4\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"As seen from the example, ",(0,o.kt)("strong",{parentName:"p"},"filter()")," allows us to filter values, and decide if we want a particular value to pass or not."),(0,o.kt)("h2",{id:"skip-first-take"},(0,o.kt)("strong",{parentName:"h2"},"skip(), first(), take()")),(0,o.kt)("p",null,"Sometimes we need to skip several values, or, on the contrary, only work on the first few. Let's see how we can do that using the ",(0,o.kt)("strong",{parentName:"p"},"filter()")," operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { filter } from "rxjs/operators";\n\nconst source = from([1, 2, 3]).pipe(\n  // Will skip the first value and return the next\n\n  filter((value, index) => index > 0)\n);\n\n// Will log:\n\n//. 2\n\n//. 3\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"RxJS")," provides us with built-in operators for such tasks. Let's see the ",(0,o.kt)("strong",{parentName:"p"},"skip()")," operator in action and rewrite the code above:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"skip()")," operator allows us to skip several values from the start of the stream."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { skip } from "rxjs/operators";\n\nconst source = from([1, 2, 3]).pipe(\n  // Will skip the first value and let every other value after that to pas\n\n  skip(1)\n);\n\n// Will log:\n\n//. 2\n\n//. 3\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"We replaced ",(0,o.kt)("strong",{parentName:"p"},"filter()")," with ",(0,o.kt)("strong",{parentName:"p"},"skip()"),", which made our code more readable and understandable. Now our code looks more declarative."),(0,o.kt)("p",null,"Now let's do the opposite, that is, take only the first several values from a stream, and ignore the rest. For that purpose, we will need operators ",(0,o.kt)("strong",{parentName:"p"},"take()")," and ",(0,o.kt)("strong",{parentName:"p"},"first()"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"take()")," takes the first several values in the stream (provided in the argument), and completes the stream."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"first()")," takes only the very first value from the stream, then completes it. Notice that if the stream completes before emitting any value, an ",(0,o.kt)("inlineCode",{parentName:"p"},"EmptyError")," will be thrown, so ",(0,o.kt)("strong",{parentName:"p"},"first()")," is fundamentally different from ",(0,o.kt)("strong",{parentName:"p"},"take(1)"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { take, first } from "rxjs/operators";\n\nconst source = from([1, 2, 3]);\n\nconst sourceTakeTwo = source.pipe(\n  // Will take the first two values from the stream and complete it\n\n  take(2)\n);\n\n// Will log:\n\n//. 1\n\n//. 2\n\nsourceTakeTwo.subscribe((value) => console.log(value));\n\nconst sourceTakeFirst = source.pipe(\n  // Will take the very first value and complete the stream\n\n  first()\n);\n\n// Will log:\n\n//. 1\n\nsourceTakeFirst.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"Great! Now that we know how to take the first values from a stream, let's see how else we can filter values using ",(0,o.kt)("strong",{parentName:"p"},"RxJS")," operators."),(0,o.kt)("h2",{id:"distinct"},(0,o.kt)("strong",{parentName:"h2"},"distinct()")),(0,o.kt)("p",null,"Sometimes we only want to operate on unique values, or in other words, ignore duplicates. For that purposes we can utilize the ",(0,o.kt)("strong",{parentName:"p"},"distinct")," operator. It will only pass values that have not been emitted yet."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { distinct } from "rxjs/operators";\n\nconst source = from([1, 2, 2, 1, 3, 2, 3, 1, 3, 2, 1, 1, 3]).pipe(\n  // Will skip duplicates\n\n  distinct()\n);\n\n// Will log:\n\n//. 1\n\n//. 2\n\n//. 3\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("h2",{id:"distinctuntilchanged"},(0,o.kt)("strong",{parentName:"h2"},"distinctUntilChanged()")),(0,o.kt)("p",null,"Sometimes though, we will need to skip duplicates, but only if they come one after another. For that, we can use the ",(0,o.kt)("strong",{parentName:"p"},"distinctUntilChanged()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"distinctUntilChanged()")," skips duplicate values that immediately follow each other."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { distinctUntilChanged } from "rxjs/operators";\n\nconst source = from([1, 1, 2, 2, 2, 3, 3, 1, 1]).pipe(\n  // Will skip the value, if it is a duplicate of the previous one\n\n  distinctUntilChanged()\n);\n\n// Will log:\n\n//. 1\n\n//. 2\n\n//. 3\n\n//. 1\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"As we can see, ",(0,o.kt)("strong",{parentName:"p"},"distinctUntilChanged()")," skipped only the first duplicates."),(0,o.kt)("h1",{id:"-1"}),(0,o.kt)("h1",{id:"combining-streams"},(0,o.kt)("strong",{parentName:"h1"},"Combining streams")),(0,o.kt)("p",null,"Sometimes we deal with tasks that require us to handle several streams simultaneously. For starters, let's create some streams to work with. For that purpose we will use the ",(0,o.kt)("strong",{parentName:"p"},"timer()")," function."),(0,o.kt)("h2",{id:"timer"},(0,o.kt)("strong",{parentName:"h2"},"timer()")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"timer()")," creates a stream that emits a value the time (in milliseconds) we provide has passed, essentially working like ",(0,o.kt)("inlineCode",{parentName:"p"},"setTimeout"),", but for streams."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { timer } from "rxjs";\n\n// First value will be emitted immediately, the next one in 1000ms\n\nconst sourceFirst = timer(0, 1000);\n\n// Will log:\n\n//. 0 immediately\n\n//. 1 in 1.0 second\n\nsourceFirst.subscribe((value) => console.log(value));\n\n// First value in 0.5 second, next one in 1 second\n\nconst sourceSecond = timer(500, 1000);\n\n// Will log:\n\n//. 0 in 0.5 sec\n\n//. 1 in 1.5 sec\n\nsourceSecond.subscribe((value) => console.log(value));\n')),(0,o.kt)("h2",{id:"interval"},(0,o.kt)("strong",{parentName:"h2"},"interval")),(0,o.kt)("p",null,"Next, let's learn how to create a stream that emits over time, but repeatedly (like ",(0,o.kt)("inlineCode",{parentName:"p"},"setInterval"),"). For that purpose, we have the ",(0,o.kt)("strong",{parentName:"p"},"interval")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { interval } from "rxjs";\n\nconst source$ = interval(1000);\n\n// Will log:\n\n//. 0 in 1 second\n\n//. 1 in 2 seconds\n\n//. 2 in 3 seconds\n\n// and so on\n\nsource$.subscribe((value) => console.log(value));\n')),(0,o.kt)("h2",{id:"combinelatest"},(0,o.kt)("strong",{parentName:"h2"},"combineLatest()")),(0,o.kt)("p",null,"Now let's combine values of those streams! We will learn to use the ",(0,o.kt)("strong",{parentName:"p"},"combineLatest()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"combineLatest()")," unites the values of all the provided streams and emits the latest emitted values of each one of them in an ",(0,o.kt)("inlineCode",{parentName:"p"},"Array"),". So, for example, if one stream emits, that value will be combined with all the latest values emitted from other ",(0,o.kt)("inlineCode",{parentName:"p"},"Observables")," in that array, and emitted together.\n",(0,o.kt)("strong",{parentName:"p"},"Important!")," Notice that ",(0,o.kt)("strong",{parentName:"p"},"combineLatest")," only starts emitting after each source ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," has emitted at least one value. Values emitted before this moment are ignored by the resulting ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { interval, combineLatest } from "rxjs";\n\nconst sourceFirst = interval(500);\n\nconst sourceSecond = interval(1000);\n\nconst source = combineLatest([sourceFirst, sourceSecond]);\n\n// Will log:\n\n//. [1, 0] in 1 second\n\n//. [2, 0] in 1.5 seconds\n\n// [3, 1] in 2 seconds\n\n// and so on\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"Despite the values of these two streams are generated at different times, we manage to combine them into a single value which allows us to handle values from two different streams simultaneously. ",(0,o.kt)("strong",{parentName:"p"},"combineLatest")," allows us to combine as many ",(0,o.kt)("inlineCode",{parentName:"p"},"Observables")," as we want, not just two."),(0,o.kt)("h2",{id:"withlatestfrom"},(0,o.kt)("strong",{parentName:"h2"},"withLatestFrom()")),(0,o.kt)("p",null,"As you could see, we received a new value each time any of the two streams emitted. But what if we need to receive a value only when the source ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," emits? Let's achieve that using the ",(0,o.kt)("strong",{parentName:"p"},"withLatestFrom()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"withLatestFrom()")," combines the source ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," with another one, and emits a combined value only when the source one emits."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { interval } from "rxjs";\n\nimport { withLatestFrom } from "rxjs/operators";\n\nconst sourceFirst = interval(1000);\n\nconst sourceSecond = interval(500);\n\nconst source = sourceFirst.pipe(withLatestFrom(sourceSecond));\n\n// Will log:\n\n//. [0, 1] in 1.0 second\n\n// [1, 3] in 2.0 seconds\n\n// [2, 5] in 3.0 seconds\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"The only difference from ",(0,o.kt)("strong",{parentName:"p"},"combineLatest")," is that it will only emit when the source ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," emits. It won't emit if the ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," we passed to ",(0,o.kt)("strong",{parentName:"p"},"withLatestFrom")," has not emitted at all, even when the source ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," emits. This is similar to ",(0,o.kt)("strong",{parentName:"p"},"combineLatest"),", for instance in this example, the first emission from ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceSecond")," will be ignored."),(0,o.kt)("h1",{id:"-2"}),(0,o.kt)("h1",{id:"handling-errors-in-streams"},(0,o.kt)("strong",{parentName:"h1"},"Handling errors in streams")),(0,o.kt)("p",null,"In real life application some exceptional situations may arise, in which cases we will need to correctly handle errors. Let's create an error and see how it goes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { from } from "rxjs";\n\nimport { map } from "rxjs/operators";\n\nconst source = from([1, 2, 3]).pipe(\n  // Something went wrong!\n\n  map(() => {\n    throw new Error("Unexpected \ud83d\ude40!");\n  })\n);\n\n// An Error will be thrown:\n\n//. Error: Unexpected \ud83d\ude40!\n\nsource.subscribe((value) => console.log(value));\n')),(0,o.kt)("p",null,"In this case, this ",(0,o.kt)("inlineCode",{parentName:"p"},"Error")," is not being handled at all. Before we get started though, let's learn how to throw errors the RxJS way.\nIn some situations, we may need to throw errors ourselves (for example, if an invalid value arises in the stream). This can be done using the ",(0,o.kt)("inlineCode",{parentName:"p"},"throwError")," function. Let's get to know it: ",(0,o.kt)("inlineCode",{parentName:"p"},"throwError")," is a function that returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"Observable")," that immediately throws an error, which we can specify with its argument. Here it is in action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { throwError } from "rxjs";\n\nthrowError("Something went wrong").subscribe(\n  (value) => console.log(value),\n  (error) => console.log(error)\n);\n\n// Will log "something wen wrong: in the console as an error (colored red)\n')),(0,o.kt)("p",null,"In this example, we have provided a second callback to the ",(0,o.kt)("inlineCode",{parentName:"p"},".subscribe")," function. This is the error callback, which gets called if there is an unhandled error in the stream."),(0,o.kt)("p",null,"To handle it, we will need to learn how to use the ",(0,o.kt)("strong",{parentName:"p"},"catchError()")," operator."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"catchError()")," handles all the errors that happen inside the stream. Notice that when an error happens, the old stream completes, so we need to return a new stream from that operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { throwError, of } from 'rxjs';\n\nimport { catchError } from 'rxjs/operators';\n\nconst source = throwError('Something went wrong!').pipe(\n  // Something went wrong!\n  // Let's handle it!\n\n  catchError(() => of(\"Error handled \ud83d\ude3b!\")),\n);\n\n// Will log:\n\n//. Error handled \ud83d\ude3b!\n\nsource.subscribe(value => console.log(value);\n")),(0,o.kt)("p",null,"Now we can be sure the code will work correctly, and all the errors will be handled."),(0,o.kt)("h1",{id:"in-conclusion"},(0,o.kt)("strong",{parentName:"h1"},"In Conclusion")),(0,o.kt)("p",null,"We got to know the most common ",(0,o.kt)("strong",{parentName:"p"},"RxJS")," operators and learnt to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Change values in a stream"),(0,o.kt)("li",{parentName:"ul"},"Filter values"),(0,o.kt)("li",{parentName:"ul"},"Combine streams"),(0,o.kt)("li",{parentName:"ul"},"Handle errors")))}c.isMDXComponent=!0}}]);