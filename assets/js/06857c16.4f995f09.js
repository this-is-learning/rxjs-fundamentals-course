"use strict";(self.webpackChunkrxjs_fundamentals_course=self.webpackChunkrxjs_fundamentals_course||[]).push([[173],{5147:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return m}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),o=["components"],l={id:"part-7",title:"Part 7. Functional Programming"},s="Functional Programming",u={unversionedId:"part-7",id:"part-7",isDocsHomePage:!1,title:"Part 7. Functional Programming",description:"Contributors:",source:"@site/docs/part-7.md",sourceDirName:".",slug:"/part-7",permalink:"/rxjs-fundamentals-course/docs/part-7",editUrl:"https://github.com/this-is-learning/rxjs-fundamentals-course/edit/main/docs/part-7.md",tags:[],version:"current",frontMatter:{id:"part-7",title:"Part 7. Functional Programming"},sidebar:"tutorialSidebar",previous:{title:"Part 6. Creational operators",permalink:"/rxjs-fundamentals-course/docs/part-6"}},c=[{value:"Introduction",id:"introduction",children:[]},{value:"What is Functional Programming really?",id:"what-is-functional-programming-really",children:[{value:"Functional Programming is declarative",id:"functional-programming-is-declarative",children:[]}]},{value:"Functional Programming concepts",id:"functional-programming-concepts",children:[{value:"Immutability",id:"immutability",children:[]},{value:"Pure functions and side effects",id:"pure-functions-and-side-effects",children:[]},{value:"Referential transparency",id:"referential-transparency",children:[]},{value:"Partial application and Currying",id:"partial-application-and-currying",children:[]},{value:"Function composition",id:"function-composition",children:[]},{value:"High Order Functions",id:"high-order-functions",children:[]},{value:"Point-Free Notation",id:"point-free-notation",children:[]}]}],p={toc:c};function m(n){var e=n.components,t=(0,i.Z)(n,o);return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"functional-programming"},"Functional Programming"),(0,r.kt)("p",null,"Contributors:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Sergi Dote Teixidor")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Functional programming is a paradigm that puts attention on functions. But this definition can be a little confusing since developers are coding using functions and methods and this doesn't mean they are programming following the Functional Programming paradigm."),(0,r.kt)("p",null,"Functional Programming talks about abstract control flows, data mapping, operations, immutability, and other concepts we are reviewing in the next steps."),(0,r.kt)("p",null,"Change our mind to a Functional Programming perspective takes a while."),(0,r.kt)("h2",{id:"what-is-functional-programming-really"},"What is Functional Programming really?"),(0,r.kt)("p",null,"Functional programming comes from mathematical logic, and \u03bb-calculus. The \u03bb-calculus helps us to describe programs as data transformations using function applications."),(0,r.kt)("p",null,"Functional Programming teaches us to decompose a problem into simple functions and chain them to get a result. Thinking like this, we can break the complexity of a program and achieve any problem as a sequence of easy steps."),(0,r.kt)("p",null,"A perfect description is what Michael Feathers said:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"OO makes code understandable by encapsulating moving parts. FP makes code understandable by minimizing moving parts.")),(0,r.kt)("h3",{id:"functional-programming-is-declarative"},"Functional Programming is declarative"),(0,r.kt)("p",null,"There are two programming paradigms:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Imperative:"),"\nIt determines HOW TO DO things, describing step by step what we need to do to get our result. Each instruction changes the state."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Declarative:"),"\nIt determines WHAT TO DO, not HOW."),(0,r.kt)("p",null,"Under this paradigm we define which operations are involved but we don't specify how to do in the low-level (loops, conditions, assignments, ...)."),(0,r.kt)("p",null,"Functional programming is declarative, it defines operations and data flows without any strict control flow definition."),(0,r.kt)("h2",{id:"functional-programming-concepts"},"Functional Programming concepts"),(0,r.kt)("p",null,"In this section, we list the key features of FP."),(0,r.kt)("h3",{id:"immutability"},"Immutability"),(0,r.kt)("p",null,"We cannot modify immutable data after its creation. When mutating data, we are producing side effects and we cannot ensure the program's correctness."),(0,r.kt)("p",null,"Immutability is a core concept of Functional Programming, without it, you cannot ensure the data flow is working properly, getting a buggy program."),(0,r.kt)("h3",{id:"pure-functions-and-side-effects"},"Pure functions and side effects"),(0,r.kt)("p",null,"With Functional Programming our code becomes immutable, using pure functions. Pure functions don\u2019t manipulate outer variables or input parameters: ",(0,r.kt)("strong",{parentName:"p"},"Same inputs produce same outputs.")),(0,r.kt)("p",null,"Pure functions don\u2019t have side effects, getting a simpler code."),(0,r.kt)("p",null,"This is a pure function (we never mutate the ",(0,r.kt)("inlineCode",{parentName:"p"},"val")," parameter):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const increment = (val: number) => val + 1;\n")),(0,r.kt)("p",null,"When using impure functions, we are running into side effects. In this case we cannot predict code alterations, and that produces buggy code. Side effects modify the state of the program or system, resulting an uncontrollable and unreliable code."),(0,r.kt)("p",null,"This is an impure function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function increment(val: number): number {\n    val += 1;\n    return val;\n}\n")),(0,r.kt)("h3",{id:"referential-transparency"},"Referential transparency"),(0,r.kt)("p",null,"A function that with the same inputs always produces the same output, is a referentially transparent function."),(0,r.kt)("p",null,"That means we can replace this kind of functions by their expression without changing the program behavior. This statement is an important pillar providing us correctness and algorithm simplicity and allowing lazy evaluation and memorization."),(0,r.kt)("h3",{id:"partial-application-and-currying"},"Partial application and Currying"),(0,r.kt)("p",null,"Partial application means fixing any number of arguments to a function, producing another function of smaller arity."),(0,r.kt)("p",null,"The currying concept (created Haskell Curry) is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument."),(0,r.kt)("p",null,"For instance, this function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function add(a: number, b: number): number {\n    return a + b;\n}\n")),(0,r.kt)("p",null,"We can curry the function like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const add = (a: number) => (b: number) => a + b;\n")),(0,r.kt)("p",null,"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const ten = add(5)(5);\n")),(0,r.kt)("p",null,"With currying, we can create new functions from others:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const add10 = add(10);\n\nconst result = add10(5);\n")),(0,r.kt)("p",null,"By defining the ",(0,r.kt)("inlineCode",{parentName:"p"},"add10")," function, we have a new function that we execute when we have provided all parameters (the function requires a second parameter)."),(0,r.kt)("h3",{id:"function-composition"},"Function composition"),(0,r.kt)("p",null,"Pure functions can be composed to get our expected result. Using the function composition technique, we can decompose any problem into simpler functions with only one responsibility and solve it by chaining these pieces."),(0,r.kt)("p",null,"In the following, we solve a given a problem first with imperative code, then declarativelly with Functional Programming using function composition."),(0,r.kt)("p",null,"Having this interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"enum Gender {\n  Female = 'Female',\n  Male = 'Male',\n  Other = 'Other'\n}\n\ninterface Student {\n  name: string;\n  lastName: string;\n  gender: Gender;\n  university: string;\n}\n")),(0,r.kt)("p",null,"We want to find all women studying in 'Union College'."),(0,r.kt)("p",null,"Under an imperative perspective, can be solve like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function getWomenFromUnionCollege(students: Array<Student>) {\n  const women = [];\n\n  for (const s of students) {\n    if (s.gender === Gender.Female && s.university === 'Union College') {\n      women.push(s);\n    }\n  }\n\n  return women;\n}\n")),(0,r.kt)("p",null,"This function has a single responsibility but is not reusable and we are instructing the program on what to do to reach the result."),(0,r.kt)("p",null,"One solution following a Functional Programming approach, could be this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const select =\n  <T, K extends keyof T & string = any>(key: keyof T, value: T[K]) =>\n  (obj: T) =>\n    obj[key] === value;\n\nconst isWoman = select<Student>('gender', Gender.Female);\n\nconst getWomen = (students: Array<Student>) => students.filter(isWoman);\n\nconst fromUnionCollege = select<Student>('university', 'Union College');\n\nconst womenFromUnionCollege = getWomen(students).filter(fromUnionCollege);\n")),(0,r.kt)("p",null,"In this case we are telling what we need, but not how to do this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We have a generic function (",(0,r.kt)("inlineCode",{parentName:"li"},"select"),"), that we use to create another function."),(0,r.kt)("li",{parentName:"ul"},"By combining the functions, we get the desired result.")),(0,r.kt)("h4",{id:"function-chaining"},"Function chaining"),(0,r.kt)("p",null,"Talking about function composition, a related concept is ",(0,r.kt)("em",{parentName:"p"},"function chaining"),". It is another way to combine functions to get a result. An example is RxJS' ",(0,r.kt)("inlineCode",{parentName:"p"},"pipe")," function which allows us to chain operators, creating a data flow that will give us the final value."),(0,r.kt)("p",null,"Let's create the ",(0,r.kt)("inlineCode",{parentName:"p"},"pipe")," function for chaining pure functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pipe = (fns) => (x) => fns.reduce((v, f) => f(v), x);\n")),(0,r.kt)("p",null,"Using this previous definition, we can chain functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const oddNumbers = (numbers: Array<number>) => numbers.filter(_ => _ % 2 !== 0);\n\nconst power = (pow: number) => (numbers: Array<number>) => numbers.map(_ => _ ** pow);\n\n pipe(\n    oddNumbers,\n    power(2),\n  )([1, 2, 3, 4, 5, 6, 7, 8, 9]) // output: [1, 9, 25, 49, 81]\n")),(0,r.kt)("p",null,"Because all involved functions are pure, we can ensure the result has never any side effect."),(0,r.kt)("h3",{id:"high-order-functions"},"High Order Functions"),(0,r.kt)("p",null,"In Functional Programming, a function is a first-class citizen of the language which means that a function is just another value."),(0,r.kt)("p",null,"A good example is the JavaScript ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];\n")),(0,r.kt)("p",null,"A function that will apply a function given as a parameter."),(0,r.kt)("p",null,"This is so powerful. Let's see an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const repeat = (times, funct, initial) =>\n  times > 1 ? repeat(times - 1, funct, funct(initial)) : funct(initial);\n")),(0,r.kt)("p",null,"This function will repeat given function N times from an initial value. The good thing is having this function we can do other functions, only passing the function we want to work with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const rateMovie = (stars) => repeat(stars, (_) => _ + '*', '');\n\nconsole.log(rateMovie(5)); // output: *****\n")),(0,r.kt)("p",null,"or:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const increment = (value) => (times) => repeat(times, (_) => _ + 1, value);\n\nconsole.log(increment(2)(1)); // output: 3\n")),(0,r.kt)("h3",{id:"point-free-notation"},"Point-Free Notation"),(0,r.kt)("p",null,"Because Functional Programming is about readability too, how we write code is particularly important."),(0,r.kt)("p",null,"Let's explain the concept with an example. Given this function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const isBiggerThan10 = (x: number) => x > 10;\n")),(0,r.kt)("p",null,"Which we can use like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"[1,2,3,20,34,12,6].filter(num => isBiggerThan10(num));\n")),(0,r.kt)("p",null,"Obviously, this is working but could be easier to read."),(0,r.kt)("p",null,"We specify the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"num")," twice. Because the inner function is expecting the same declared parameter in the left part of the provided function, we can apply point-free notation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"[1,2,3,20,34,12,6].filter(isBiggerThan10);\n")),(0,r.kt)("p",null,"We have reduced verbosity which implies simplicity."))}m.isMDXComponent=!0}}]);