"use strict";(self.webpackChunkrxjs_fundamentals_course=self.webpackChunkrxjs_fundamentals_course||[]).push([[125],{5114:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return c}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),o=["components"],i={id:"part-4",title:"Part 4. How RxJS is used by Angular"},l="How RxJS is used by Angular",p={unversionedId:"part-4",id:"part-4",isDocsHomePage:!1,title:"Part 4. How RxJS is used by Angular",description:"Contributors:",source:"@site/docs/part-4.md",sourceDirName:".",slug:"/part-4",permalink:"/rxjs-fundamentals-course/docs/part-4",editUrl:"https://github.com/this-is-learning/rxjs-fundamentals-course/edit/main/docs/part-4.md",tags:[],version:"current",frontMatter:{id:"part-4",title:"Part 4. How RxJS is used by Angular"},sidebar:"tutorialSidebar",previous:{title:"Part 3. The most common RxJS operators",permalink:"/rxjs-fundamentals-course/docs/part-3"},next:{title:"Part 5. Everything is a stream: Push-based architecture",permalink:"/rxjs-fundamentals-course/docs/part-5"}},u=[{value:"HttpClientModule",id:"httpclientmodule",children:[]},{value:"Forms",id:"forms",children:[]},{value:"Querying elements from the DOM",id:"querying-elements-from-the-dom",children:[]},{value:"Routing",id:"routing",children:[]}],m={toc:u};function c(e){var t=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"how-rxjs-is-used-by-angular"},"How RxJS is used by Angular"),(0,s.kt)("p",null,"Contributors:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Andrei Gatej")),(0,s.kt)("h1",{id:"how-rxjs-is-used-by-angular-1"},"How RxJS is used by Angular"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Writer: Andrei Gatej")),(0,s.kt)("p",null,"In this chapter, we're going to expose which parts of Angular are powered by RxJS, along with some practical examples."),(0,s.kt)("h2",{id:"httpclientmodule"},"HttpClientModule"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"If you'd like to follow along, you could open this")," ",(0,s.kt)("a",{parentName:"p",href:"https://stackblitz.com/edit/rxjs-basics-http?file=src%2Fapp%2Fapp.component.ts"},(0,s.kt)("em",{parentName:"a"},"StackBlitz demo")),(0,s.kt)("em",{parentName:"p"},".")),(0,s.kt)("p",null,"Making requests over the network definitely complies with a well known Observable definition: ",(0,s.kt)("em",{parentName:"p"},"data which comes over time"),". With this in mind, an HTTP request can be seen as an Observable that will emit some data at some point in the future. Let's see how it would look like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"users$: Observable<any[]> = this.http.get<any[]>(this.url);\n\nconstructor (private http: HttpClient) { }\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("em",{parentName:"p"},"HttpClient.get(url)")," method will perform a GET request to the specified ",(0,s.kt)("em",{parentName:"p"},"url.")," This method(and the similar ones, e.g ",(0,s.kt)("em",{parentName:"p"},"post, put")," etc...) will return an ",(0,s.kt)("em",{parentName:"p"},"Observable")," which will emit once the response is ready and then it will emit a ",(0,s.kt)("em",{parentName:"p"},"complete notification.")," This implies that there is ",(0,s.kt)("strong",{parentName:"p"},"no need")," to explicitly unsubscribe from an observable returned from ",(0,s.kt)("em",{parentName:"p"},"HttpClient.")),(0,s.kt)("p",null,"In order to get a better understanding, here's how you could loosely implement something similar to what the ",(0,s.kt)("em",{parentName:"p"},"HttpClient")," does:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"new Observable((subscriber) => {\n  // Make the request here, e.g using `fetch` or `XMLHttpRequest`\n  // Then, after the response(`resp`) is ready\n  subscriber.next(resp);\n  subscriber.complete();\n});\n")),(0,s.kt)("p",null,"Another great feature the ",(0,s.kt)("em",{parentName:"p"},"HttpClientModule")," provides is the ability to intercept and alter the ",(0,s.kt)("strong",{parentName:"p"},"requests")," and ",(0,s.kt)("strong",{parentName:"p"},"their responses.")," This can be achieved with ",(0,s.kt)("strong",{parentName:"p"},"Interceptors.")),(0,s.kt)("p",null,"For example, this is how an interceptor can be provided:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"{ provide: HTTP_INTERCEPTORS, useClass: TokenInterceptor, multi: true }\n")),(0,s.kt)("p",null,"And this is how it might be implemented:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    // Altering the incoming request, e.g: adding necessary headers\n    const newReq = req.clone({\n      setHeaders: { Authorization: "<schema-type> <credentials>" },\n    });\n\n    return next.handle(newReq).pipe(\n      // Altering the response\n      // Only interested in `Response` events. Others could be: `Sent`, `UploadProgress` etc...\n      filter((e) => e.type === HttpEventType.Response)\n\n      // Can also retry requests, maybe the authorization token expired, so we can use the refresh token to get a new one\n      // catchError(err => handleExpired()),\n    );\n  }\n}\n')),(0,s.kt)("p",null,"As you can see, interceptors come up with a lot of possibilities. This is possible because RxJS' Observables can be ",(0,s.kt)("strong",{parentName:"p"},"composed"),"."),(0,s.kt)("p",null,"For example, you might have something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const be$ = new Observable((subscriber) => {\n  setTimeout(() => {\n    // After the request is ready\n    subscriber.next({ data: {}, err: null });\n    subscriber.complete();\n  }, 3000);\n});\n\n// Applying an interceptor\nconst intercepted$ = be$.pipe(filter(/* ... */), catchError(/* ... */));\n\n// Applying another interceptor\nconst interceptedTwice$ = intercepted$.pipe(/* ... */);\n")),(0,s.kt)("h2",{id:"forms"},"Forms"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"If you'd like to follow along, you could open this")," ",(0,s.kt)("a",{parentName:"p",href:"https://stackblitz.com/edit/rxjs-basics-forms?file=src/app/app.component.ts"},(0,s.kt)("em",{parentName:"a"},"StackBlitz demo")),(0,s.kt)("em",{parentName:"p"},".")),(0,s.kt)("p",null,"Sometimes, when working with Angular Forms, you might need to perform certain actions when the ",(0,s.kt)("strong",{parentName:"p"},"value")," or the ",(0,s.kt)("strong",{parentName:"p"},"status")," of a ",(0,s.kt)("strong",{parentName:"p"},"form control")," changes. You can be notified about these events with the help of ",(0,s.kt)("em",{parentName:"p"},"valueChanges")," and ",(0,s.kt)("em",{parentName:"p"},"statusChanges"),"."),(0,s.kt)("p",null,"Let's see how they can be used:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'this.valueChangesSub = this.myCtrl.valueChanges.subscribe((v) => {\n  console.log("value changed", v);\n});\n\nthis.statusChangesSub = this.myCtrl.statusChanges.subscribe((v) => {\n  console.log("status changed", v);\n});\n')),(0,s.kt)("p",null,"When typing into the input, both the registered callbacks will be called. ",(0,s.kt)("em",{parentName:"p"},"valueChanges")," emits when the ",(0,s.kt)("strong",{parentName:"p"},"control's value")," has changed and ",(0,s.kt)("em",{parentName:"p"},"statusChanges")," when the ",(0,s.kt)("strong",{parentName:"p"},"control's status")," changed(e.g from ",(0,s.kt)("em",{parentName:"p"},"INVALID")," to ",(0,s.kt)("em",{parentName:"p"},"VALID"),")."),(0,s.kt)("p",null,"As with every observable, you can apply ",(0,s.kt)("strong",{parentName:"p"},"operators")," to it. For instance, you might want to be notified only when the current status is different than the previous one:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'this.statusChangesSub = this.myCtrl.statusChanges\n  .pipe(distinctUntilChanged())\n  .subscribe((v) => {\n    console.log("status changed", v);\n  });\n')),(0,s.kt)("p",null,"One thing that you should be mindful of is that you ",(0,s.kt)("strong",{parentName:"p"},"don't")," have to unsubscribe from these observables when the component is destroyed because the data producer(e.g ",(0,s.kt)("em",{parentName:"p"},"valueChanges"),") belongs to the component in question, thus everything becomes eligible for garbage collection."),(0,s.kt)("h2",{id:"querying-elements-from-the-dom"},"Querying elements from the DOM"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"If you'd like to follow along, you could open this")," ",(0,s.kt)("a",{parentName:"p",href:"https://stackblitz.com/edit/rxjs-basics-query?file=src%2Fapp%2Fapp.component.ts"},(0,s.kt)("em",{parentName:"a"},"StackBlitz demo")),(0,s.kt)("em",{parentName:"p"},".")),(0,s.kt)("p",null,"You might be familiar with ",(0,s.kt)("em",{parentName:"p"},"ViewChildren")," and ",(0,s.kt)("em",{parentName:"p"},"ContentChildren")," decorators. They can be used to query elements from a component's view and from a component's projected content, respectively. Both return a ",(0,s.kt)("em",{parentName:"p"},"QueryList")," type."),(0,s.kt)("p",null,"One thing that might come handy in certain situations is to be notified about changes that occur in the list obtained, changes such as ",(0,s.kt)("strong",{parentName:"p"},"addition")," or ",(0,s.kt)("strong",{parentName:"p"},"removal.")," This is possible as the ",(0,s.kt)("em",{parentName:"p"},"QueryList")," structure exposes a ",(0,s.kt)("em",{parentName:"p"},"changes")," property which emits whenever the actions delineated above take place."),(0,s.kt)("p",null,"Here is an example of ",(0,s.kt)("em",{parentName:"p"},"ViewChildren:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-html"},'<ul>\n  <li *ngFor="let _ of [].constructor(total); index as idx" #item>\n    {{ idx + 1 }}\n  </li>\n</ul>\n\n<hr />\n<br />\n\n<button (click)="total = total - 1 < 0 ? 0 : total - 1">Remove Item</button>\n<button (click)="total = total + 1" style="margin-left: 3rem;">Add Item</button>\n')),(0,s.kt)("p",null,"And the corresponding TS file:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({ ... })\nexport class AppComponent {\n  total = 10;\n\n  @ViewChildren('item') private items: QueryList<HTMLUListElement>;\n\n  ngAfterViewInit () {\n    this.items.changes.subscribe(changes => {\n      console.log('changes occurred', changes);\n    });\n  }\n}\n")),(0,s.kt)("p",null,"One thing that is worth mentioning is that you don't have to unsubscribe when the component is destroyed as this is handled internally by ",(0,s.kt)("em",{parentName:"p"},"QueryList.")),(0,s.kt)("h2",{id:"routing"},"Routing"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"If you'd like to follow along, you could open this")," ",(0,s.kt)("a",{parentName:"p",href:"https://stackblitz.com/edit/rxjs-basics-routing?file=src/app/app.module.ts"},(0,s.kt)("em",{parentName:"a"},"StackBlitz demo")),(0,s.kt)("em",{parentName:"p"},".")),(0,s.kt)("p",null,"Another significant part where Angular heavily uses RxJS is ",(0,s.kt)("strong",{parentName:"p"},"routing"),"."),(0,s.kt)("p",null,"For instance, when you want to manage the access to certain routes, you can leverage ",(0,s.kt)("strong",{parentName:"p"},"guards"),"."),(0,s.kt)("p",null,"Each guard can return, among others, ",(0,s.kt)("em",{parentName:"p"},"Observables,")," allowing you to perform complex logic when deciding whether the route should be accessed or not."),(0,s.kt)("p",null,"Let's see an example of ",(0,s.kt)("em",{parentName:"p"},"CanActivate:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"canActivate(\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot\n): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {\n  // The logic might involve Observables\n  return timer(1000).pipe(\n    map(() => true),\n  );\n}\n")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Note: the same concept can be applied to other guards.")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Observables")," can also be used when implementing ",(0,s.kt)("strong",{parentName:"p"},"route resolvers:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'export class HelloResolver implements Resolve<any> {\n  constructor(private http: HttpClient) {}\n\n  resolve(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<any> | Promise<any> | any {\n    return this.http\n      .get<any>("https://jsonplaceholder.typicode.com/posts")\n      .pipe(map((arr) => arr.slice(0, 10)));\n  }\n}\n')),(0,s.kt)("p",null,"The result of the resolver can then be accessed in the component route's component through the ",(0,s.kt)("em",{parentName:"p"},"ActivatedRoute.data")," property."))}c.isMDXComponent=!0}}]);