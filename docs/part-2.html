<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Part 2. Reactive programming and RxJS · RxJS Fundamentals</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Reactive programming and RxJS"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Part 2. Reactive programming and RxJS · RxJS Fundamentals"/><meta property="og:type" content="website"/><meta property="og:url" content="https://this-is-learning.github.io/rxjs-fundamentals-course/"/><meta property="og:description" content="# Reactive programming and RxJS"/><meta property="og:image" content="https://this-is-learning.github.io/rxjs-fundamentals-course/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://this-is-learning.github.io/rxjs-fundamentals-course/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/rxjs-fundamentals-course/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/rxjs-fundamentals-course/js/scrollSpy.js"></script><link rel="stylesheet" href="/rxjs-fundamentals-course/css/main.css"/><script src="/rxjs-fundamentals-course/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/rxjs-fundamentals-course/"><img class="logo" src="/rxjs-fundamentals-course/img/favicon.ico" alt="RxJS Fundamentals"/><h2 class="headerTitleWithLogo">RxJS Fundamentals</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/rxjs-fundamentals-course/docs/part-1" target="_self">Course</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Part 2</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 1</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-1">Part 1. RxJS: better async programming</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 2</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-2">Part 2. Reactive programming and RxJS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 3</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-3">Part 3. The most common RxJS operators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 4</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-4">Part 4. How RxJS is used by Angular</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 5</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-5">Part 5. Everything is a stream: Push-based architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 6</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-6">Part 6. Creational operators</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Part 2. Reactive programming and RxJS</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="reactive-programming-and-rxjs"></a><a href="#reactive-programming-and-rxjs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reactive programming and RxJS</h1>
<p>Contributors:</p>
<ul>
<li>Nate Lapinski</li>
<li>Alain Boudard</li>
<li>Maina Wycliffe</li>
</ul>
<h1><a class="anchor" aria-hidden="true" id="fundamentals-of-rxjs"></a><a href="#fundamentals-of-rxjs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fundamentals of RxJS</h1>
<h2><a class="anchor" aria-hidden="true" id="chapter-2-reactive-programming-with-rxjs"></a><a href="#chapter-2-reactive-programming-with-rxjs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chapter 2: Reactive Programming with RxJS</h2>
<ul>
<li>What is declarative programming ?</li>
<li>What is the Observer pattern, and how does it relate to the Iterator pattern ?</li>
</ul>
<p>And many others. Along the way, we'll build a very simple Observable of our own, and we'll even touch on a couple of topics from the world of functional programming.</p>
<h2><a class="anchor" aria-hidden="true" id="chapter-contents"></a><a href="#chapter-contents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chapter Contents:</h2>
<ul>
<li>Declarative and Imperative programming</li>
<li>Reactive Programming</li>
<li>The Iterator and Observer patterns</li>
<li>arrays as iterables</li>
<li>iterators as pull</li>
<li>observers as push</li>
<li>symmetry between iterators and observers</li>
<li>Streams of data</li>
<li>Observables - an implementation of the Observer pattern</li>
<li>observers</li>
<li>subscribers</li>
<li>subscriptions and subjects</li>
<li>Operators - composition with Observables</li>
<li>map and filter</li>
<li>pipelines: the flow of data through an observable. Transducers.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="declarative-and-imperative-programming"></a><a href="#declarative-and-imperative-programming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Declarative and Imperative Programming</h2>
<p>The difference between these two styles of programming is perhaps best illustrated with an example.</p>
<p><strong>Challenge: Write a program which takes the array <code>x = [1,2,3,4,5]</code>, and produces a new array, <code>y</code>, by adding one to each element in <code>x</code>. The result should be <code>[2,3,4,5,6]</code>.</strong></p>
<p><strong>Solution 1: Use a loop</strong></p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">let</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> y = [];

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; x.length; i++) {
  y.push(x[i] + <span class="hljs-number">1</span>);
}

<span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// [2,3,4,5,6]</span>
</code></pre>
<p><strong>Solution 2: Use map</strong></p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> add1 = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n + <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-keyword">let</span> y = x.map(add1);

<span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// [2,3,4,5,6]</span>
</code></pre>
<p>The difference between declarative and imperative programming can be a little subtle at first. <strong>Solution 1</strong> is an example of <em>imperative programming</em>, which is usually described as telling the computer exactly how to calculate what we want, step by step. Notice the loop. We are stepping through each and every element of the array x, and saying how to transform it (by adding 1 to it), and then saying how to place it in the array y (by calling y.push). It's a sort of &quot;do step1, then do step2, then do step3…&quot; approach where we explicitly specify everything.</p>
<p><strong>Solution 2</strong> is an example of declarative programming. Notice how we've shied away from explicit implementation details, and are describing or &quot;declaring&quot; what we want to happen by using the map method from Array.prototype. We're simply stating &quot;Take the array x, apply the function add1 to every element, and give me the results in a new array called y&quot;.</p>
<p>Sometimes, this difference can feel like a matter of preference. At the end of the day, both solutions produce the correct answer, and there's certainly nothing wrong with loops (we'll see later on how map can be implemented internally using a loop). However, when we deal with asynchronous programming, we'll see that the declarative solution is preferable. Why is that? Notice a couple of things about our two solutions:</p>
<p>Solution 1 is very clearly <strong>synchronous</strong> (a loop must always be synchronous), and it's not <em>composable</em> (more on this later).</p>
<p>Solution 2 is a little more interesting. x is an array, so we know that this code is synchronous. However, the <em>concept</em> of mapping over something could very well be asynchronous. We haven't really specified any implementation details with the map, just that we want to apply the function add1 to every element inside of the container x. Maybe those elements are all in memory at once (synchronous), or maybe they are arriving over the network over an interval of time (asynchronous). Indeed, we will see that RxJS has its own map operator, whose semantics aren't so far removed from that of Array.prototype.map.</p>
<p>Another thing to note about Solution 2 is that it is <em>composable</em>, meaning we could chain or <em>pipe</em> a sequence of operations together. For plain Javascript code, composition is mostly based on the return value of the function : if map() does return a new Array, we can call another function on this result. Composition will be explained in more detail in the section on operators, so don't worry about it right now. The reason it keeps coming up is because composition of operators is one of the things that makes RxJS so powerful. Should you choose to one day venture into the lands of a language like Haskell, you'll see that composition is one of the foundations of functional programming - it's not a concept that's unique to arrays or RxJS.</p>
<h2><a class="anchor" aria-hidden="true" id="reactive-programming"></a><a href="#reactive-programming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reactive Programming</h2>
<p>Reactive Programming is being able to work with an asynchronous stream of data. You can think of this as a pipe, where data is flowing from one end to the other. You can then observe this stream of data and do something with it - react - like apply some business logic as the data flows through the pipe. These data streams can be anything, from HTTP Requests, Mouse and Keyboard events, Data from Sensors, Push Notifications, or anything that can happen. For instance, take a chat application, where two people are having a chat. Whenever a new message arrives, could be in the form of text or a reaction to the previous message, you need to react accordingly and update the UI appropriately.</p>
<p>ReactiveX (Rx), which RxJS is an implementation of, gives you a set of tools to help you compose data streams. These tools are known as <em>operators</em> and can be used to create new data streams, combine, transform, filter, join, handle errors, etc in your data streams.</p>
<p>The main goal of such an approach will be to handle nicely common issues we can have when dealing with asynchronous streams of data, like the callback hell. This expression refers to the callback function used in asynchronous functions like this (the second argument of addEventListener):</p>
<pre><code class="hljs css language-js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'test'</span>).addEventListener(<span class="hljs-string">'click'</span>, (event) =&gt; {
  <span class="hljs-built_in">console</span>.log(event.target);
});
</code></pre>
<p>This event listener is producing a stream of values, values emitted over time at each user click, and this stream virtually never completes.</p>
<p>When we will want to deal with other operations, we will have to nest the next calls in each callback function. Not only will it become had to read, but the error handling will be very complicated if not impossible. In addition, we will have to work with streams of data that never complete (like the click event) and some that do complete (like a timeout or an Ajax call).</p>
<pre><code class="hljs css language-js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'test'</span>).addEventListener(<span class="hljs-string">'click'</span>, (event) =&gt; {
  <span class="hljs-built_in">console</span>.log(event.target);
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    $.ajax({ params }).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-comment">// deal with result</span>
    });
  }, <span class="hljs-number">400</span>);
});
</code></pre>
<p>In this pseudo code, we can see callback being nested, and we see that this will cause issues very soon, like <em>what happens if user clicks multiple times ?</em> or <em>how do we cancel the operation ?</em></p>
<p>In order to deal with these streams of data, RxJs will introduce much more elegant and powerful tools such as Observables that will be discussed in the next section.</p>
<h2><a class="anchor" aria-hidden="true" id="the-iterator-and-observer-patterns"></a><a href="#the-iterator-and-observer-patterns" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Iterator and Observer patterns</h2>
<p>Iterables - data types that implement the &quot;iterator&quot; interface - are pretty common in Javascript. Perhaps the most common example is the array. Iterables are usually consumed using a <code>next</code> method. Consumers of an iteratable tend to pull data from the producer by using the <code>next</code> method. The consumer is the one in control of the flow of data.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
<span class="hljs-keyword">var</span> iterator = arr.keys();

<span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// { value: 0, done: false }</span>
<span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// { value: 2, done: false }</span>
<span class="hljs-built_in">console</span>.log(iterator.next()); <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>Note that the last value has done property set to true, meaning we <em>pulled</em> all data from the iterator.</p>
<p>By contrast, in the observer pattern, the publisher of the data <em>pushes</em> data to its subscribers, so it is in control of the flow of data.</p>
<p>The concept is pretty straightforward. There is an object containing state that will change over time. This is known as the subject in the classical Observer Pattern. All this subject does is accept callback functions from observers, which are objects that want to be notified whenever the subject's state changes. Whenever such a state change happens, the subject loops through all of the observer callbacks, and invokes them with the new state as an argument.</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">class</span> Subject {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">this</span>.callbacks = [];
  }

  subscribe(fn) {
    <span class="hljs-keyword">this</span>.callbacks.push(fn);
  }

  publish(data) {
    <span class="hljs-keyword">this</span>.callbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn(data));
  }
}

<span class="hljs-comment">// usage</span>
<span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();
<span class="hljs-keyword">const</span> observer1 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Observer1 received data: <span class="hljs-subst">${data}</span>`</span>);

subject.subscribe(observer1);
counter = <span class="hljs-number">0</span>;

setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  subject.publish(<span class="hljs-string">`test data <span class="hljs-subst">${++counter}</span>`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p>The classic observer pattern has been a staple of web development for many years. However, it provides no way of containerizing events, meaning we can't compose streams out of subject events. Ideally, we'd have some data structure that enables us to do this.</p>
<p>RxJS improves upon this classical observer pattern by introducing a more robust interface for observers, one that supports not just a method for publishing data (onNext), but also methods for notifying observers of errors (onError), as well as when there is no more data to consume (onComplete). Note that by contract, error and complete are exclusive, you either have one OR the other.
In doing this, the RxJS makes the observer pattern symmetric to the iterator pattern, in some sense.</p>
<p>Soon, we'll see how to implement a simple Observable class.</p>
<h2><a class="anchor" aria-hidden="true" id="streams-of-data"></a><a href="#streams-of-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Streams of Data</h2>
<p>We've seen how thinking about Arrays can be useful for understanding operators like map and filter, and composition over containers in general. So it should come as no surprise that they will provide a glimpse into streams.</p>
<p>In the Haskell - functional programming world, a stream is just an infinite list (array). Since Javascript has no native notion of an infinite array, let's think about how one differs from a regular array.</p>
<p>Consider the following, finite array:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

arr.map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-number">1</span>); <span class="hljs-comment">// [2,3,4,5,6]</span>
</code></pre>
<p>In this case, <code>arr</code> is finite. It's declared, and all of its values are in memory at once. We can synchronously iterate over it using Array.prototype.map, to produce a new array (<code>[2,3,4,5,6]</code>).</p>
<p>Because this array is finite, we &quot;know&quot; when it ends - it has length of five in this case. We already know that arrays are composable containers, so we can do things like map, filter, flatMap, reduce, etc, over them. How convenient.</p>
<p>But what about an &quot;infinite array&quot; ? Maybe you have an array that you'd like to use to model mouse click events, or mousemover events. How would you ever know when you are finished ? A user could click or move the mouse at any time, so this theoretical array would be infinite in some sense - we could never know when it would end.</p>
<p>And that's not really a problem, we could just listen for events and &quot;push&quot; these new events into some shared array state…</p>
<p>Still, it would be nice to have something a little more appropriate for handling asynchronicity. Like a data structure that is designed to work with potentially asynchronous, potentially infinite stream of data, while offering composable operators (map, filter, and friends). This is where observables shine. They provide us with a useful interface for consuming &quot;infinite&quot; streams of data.</p>
<p>This will all be clearer with a concrete example, so let's build a simple observable.</p>
<h2><a class="anchor" aria-hidden="true" id="observables---an-implementation-of-the-observer-pattern"></a><a href="#observables---an-implementation-of-the-observer-pattern" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Observables - an implementation of the Observer pattern</h2>
<p>Here's a simple implementation of an observable class, along with a static 'of'' method.</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">class</span> Observable {
  <span class="hljs-comment">/** Internal implementation detail */</span>
  _subscribe;

  <span class="hljs-comment">/**
   * @constructor
   * @param {Function} subscribe is the function that is called when the
   * observable is subscribed to. This function is given a subscriber/observer
   * which provides the three methods on the Observer interface:
   * onNext, onError, and onCompleted
   */</span>
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">subscribe</span>) {
    <span class="hljs-keyword">if</span> (subscribe) {
      <span class="hljs-keyword">this</span>._subscribe = subscribe;
    }
  }

  <span class="hljs-keyword">static</span> of(...args) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function">(<span class="hljs-params">obs</span>) =&gt;</span> {
      args.forEach(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> obs.onNext(val));
      obs.onCompleted();

      <span class="hljs-keyword">return</span> {
        unsubscribe: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-comment">// just make sure none of the original subscriber's methods are never called.</span>
          obs = {
            onNext: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
            onError: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
            onCompleted: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {},
          };
        },
      };
    });
  }

  <span class="hljs-comment">// public api for registering an observer</span>
  subscribe(onNext, onError, onCompleted) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onNext === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._subscribe({
        onNext: onNext,
        onError: onError || <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>) =&gt; {}</span>),
        <span class="hljs-params">onCompleted</span>: <span class="hljs-params">onCompleted</span> || (<span class="hljs-params">(<span class="hljs-params"></span>) =&gt; {}</span>),
      });
    } <span class="hljs-params">else</span> {
      <span class="hljs-params">return</span> <span class="hljs-params">this</span>._<span class="hljs-params">subscribe</span>(<span class="hljs-params">onNext</span>);
    }
  }
}

<span class="hljs-params">const</span> <span class="hljs-params">obs</span> = <span class="hljs-params">Observable</span>.<span class="hljs-params">of</span>(<span class="hljs-params">1, 2, 3, 4</span>);

<span class="hljs-params">obs</span>.<span class="hljs-params">subscribe</span>(<span class="hljs-params"><span class="hljs-built_in">console</span>.log</span>); // <span class="hljs-params">prints</span> 1,2,3,4
</span></code></pre>
<p>In this example, we take a pseudo list of values and turn it into a stream of values, this is the of() method. Basically, nothing happens with an Observable until we subscribe to it, the <em>obs</em> object is some blueprint of a stream of values.</p>
<p><strong>(Note: if keeping this example implementation makes sense, then explain it in more detail)</strong></p>
<h2><a class="anchor" aria-hidden="true" id="operators---composition-with-observables"></a><a href="#operators---composition-with-observables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operators - composition with Observables</h2>
<p>Way back in the section on declarative and imperative programming, we talked about Array.prototype's map function. We saw that it lets us apply a function to each element in an array. More generally, a map applies a transformation function (in our example, add1) over some container (in our example, the array x). RxJS has its own map. It's an example of an <em>operator</em>. In the case of RxJS, the container is not an array but an observable. Other than that, many of the concepts are similar! ( <strong>Edit: In a more advanced guide, it might be fun to talk about the difference between array's map, which will map over every element before moving to the next operation, and Observables, which iirc are transducers and instead process a single element through each operator in the pipeline before moving on</strong> )</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/rxjs-fundamentals-course/docs/part-1"><span class="arrow-prev">← </span><span class="function-name-prevnext">Part 1. RxJS: better async programming</span></a><a class="docs-next button" href="/rxjs-fundamentals-course/docs/part-3"><span class="function-name-prevnext">Part 3. The most common RxJS operators</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#chapter-2-reactive-programming-with-rxjs">Chapter 2: Reactive Programming with RxJS</a></li><li><a href="#chapter-contents">Chapter Contents:</a></li><li><a href="#declarative-and-imperative-programming">Declarative and Imperative Programming</a></li><li><a href="#reactive-programming">Reactive Programming</a></li><li><a href="#the-iterator-and-observer-patterns">The Iterator and Observer patterns</a></li><li><a href="#streams-of-data">Streams of Data</a></li><li><a href="#observables---an-implementation-of-the-observer-pattern">Observables - an implementation of the Observer pattern</a></li><li><a href="#operators---composition-with-observables">Operators - composition with Observables</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/rxjs-fundamentals-course/" class="nav-home"><img src="/rxjs-fundamentals-course/img/favicon.ico" alt="RxJS Fundamentals" width="66" height="58"/></a><div><h5>Open Learning</h5><a href="/rxjs-fundamentals-course/docs/part-1">RxJS Fundamentals</a><a href="https://dev.to/this-is-learning" target="_blank" rel="noreferrer noopener">This is Learning publication</a><a href="https://dev.to/this-is-angular" target="_blank" rel="noreferrer noopener">This is Angular publication</a></div><div><h5>Community</h5><a href="https://discord.gg/ygKzbrBtVn" target="_blank" rel="noreferrer noopener">This is Learning Community Discord</a><a href="https://github.com/this-is-learning">This is Learning GitHub</a><a href="https://github.com/this-is-angular">This is Angular GitHub</a></div><div><h5>Social</h5><a class="github-button" data-icon="octicon-star" data-count-href="/this-is-learning/rxjs-fundamentals-course/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/Thisis_Learning" class="twitter-follow-button">Follow @Thisis_Learning</a></div></div></section><section class="copyright">Licensed under CC BY-SA 4.0 by This is Learning</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>